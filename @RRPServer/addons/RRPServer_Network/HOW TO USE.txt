Первое что требуется, забыть что такое remoteExec/call, система RE уже тут встроенна.
Кстати да, отдельно передавать игрока теперь не нужно, если ссылаться на скрипт через эту систему объект игрока можно получить функцией RRPServer_session_getPlayerObject
Почему это лучше чем RE? Потому что он защищен от внешнего инжекта и все данные передаются одной только функцией
Это позволит заблокировать RE в description.ext от вообще всех функций, подкапаться к серверу никак не получится
Второе, это фильтрация данных, нельзя будет послать в вызываемую функцию рандомные данные.
Параметры отправляемые с клиента на сервер и наоборот проверяются в конфиге CfgNetworkMessages
Разберем конфиге, на примере вызова функции RRPServer_ltd_addSlots
class CfgNetworkMessages 
{
	class addSlots	//должен быть уникальным
	{
		module = "ltd";	//название модуля.
		payloads[] = 
		{
			"STRING"	//Отправляем только текст
		};
	};
};

Название всех payloads
STRING = текст.
SCALAR = число.
ARRAY = массив.
OBJECT = объект.
BOOL = true/false.
CONFIG = данные с configFile/missionConfigFile.
GROUP = данные о группе игроков.
DISPLAY = данные о диалоге.
CONTROL = данные определенного контрола в диалоге, например кнопки, тощо.
SIDE = передает фракцию, но т.к. у нас она только одна, смысла использовать нет.
CODE = компилированный код !!!ОПАСНО!!!
LOCATION = локация

Какие данные приходят в вызываемый скрипт
_sessionId = _this select 0; 	//Тот кто вызвал, получить можно _sessionId call RRPServer_session_getPlayerObject
_payload = _this select 1;		//Входящие параметры
_payload params ["_ARRAY","_STRING","_SCALAR"];	//То что в payload
Далее сам уже скрипт

Чуть сложнее чем простой RE, но привыкнуть можно.